## Lecture 6 Synchronization

#### Review:	ThreadFork(): Create a New Thread

* _ThreadFork()_ is a user-level procedure that creates a new thread and places it on ready queue
	+ We called this CreateThread() earlier

* __Arguments__ to _ThreadFork()_
	+ Pointer to application routine (fcnPtr)
	+ Pointer to array of arguments (fcnArgPtr)
	+ Size of stack to allocate

* __Implementation__
	+ Sanity Check arguments
	+ Enter Kernel-mode and Sanity Check arguments again
	+ Allocate new Stack and TCB
	+ Initialize TCB and place on ready list (Runnable)

---------------

#### Review:	How does Thread get started?

![Thread](images/05-008.png "Thread")

> We're in kernel mode when we switch.

---------------

#### Review: What does ThreadRoot() look like?

![ThreadRoot()](images/05-009.png "ThreadRoot()")

----------------

* Correctness for systems with concurrent threads (具有并发线程的系统的正确性)

![Correctness for systems with concurrent threads](images/05-015.png "Correctness for systems with concurrent threads")


+ Independent Threads
	- No state shared with other threads
	- Deterministic(确定性的) -> Input state determines results
	- Reproducible(可复制的) -> Can recreate Starting Conditions, I/O
	- Scheduling order doesn't matter (if `switch()` works!!!)


+ Cooperating Threads
	- Shared State between multiple threads
	- Non-deterministic
	- Non-reproducible

+ Non-deterministic and Non-reproducible means that __bugs can be intermittent__(间歇的)
	- Sometimes called "**Heisenbugs**"

	> Heisenbugs: these are the bugs where you go to look at them and they disappear on you.

----------------

#### Goals for Today

* Concurrency examples
* Need for synchronization(同步)
* Examples of valid synchronization

----------------

* Interactions Complicate Debugging (交互使得更难debug)

	+ Is any program truly independent ?
		- No!

	+ You probably don't realize how much you depend on reproducibility

	+ Non-deterministic errors are really difficult to find!


	![Interactions Complicate Debugging](images/05-016.png "Interactions Complicate Debugging")


----------------

* Why allow cooperating threads?

	+ People cooperate; computers help/enhance people's lives, so computers must cooperate
		- By analogy, the non-reproducibility/non-determinism of people is a notable problem for "carefully laid plans"

	+ Advantage
		1. Share resources
			- One computer, many users
			- One back balance, many ATMs ( What if ATMs were only updated at night?)
			- Embedded systems (robot control: coordinate arm & hand)

		2. Speedup
			- Overlap I/O and computation (Many different file systems do read-ahead)

		3. Modularity
			- More important than you might think
			- Chop large problem up into simpler pieces (To compile, for instance, gcc calls cpp | cc1 | cc2 | as | id )  (Makes system easier to extend)

> gcc (GNU编译器套装 GNU Compiler Collection )， 指一套编程語言编译器，以GPL及LGPL许可证所发行的自由软件，也是GNU計畫的关键部分，也是GNU工具链的主要組成部份之一。GCC（特别是其中的C语言编译器）也常被认为是跨平台编译器的事实标准。它原本只能处理C語言。GCC在发布后很快地得到扩展，变得可處理C++。之後也變得可處理Fortran、Pascal、Objective-C、Java、Ada，Go與其他語言。
>
> cpp 是程序设计语言C++的另一种书写形式。“C Plus Plus”的简称。是继C语言之后又一种计算机编程语言，C++编程语言同时支持所有的C语言语法。C++和C相似：但C是面向过程的程序设计语言，而C++是面向对象的程序设计语言，不过C++语言保持了对C语言的兼容，也就说是在C++程序可以不用修改的插入C语言代码。

----------------

* Threaded Web Server

![Threaded Web Server](images/06-001.png "Threaded Web Server")

* Advantages of Threaded Version:
	+ Can share file caches kept in memory, results of CGI scripts, other things
	+ Threads are __much cheaper to create than processes__, so this has a lower per-request overhead

> CGI (Common Gateway Interface, 通用网关接口), 是Web 服务器运行时外部程序的规范,按CGI 编写的程序可以扩展服务器功能。CGI 应用程序能与浏览器进行交互,还可通过数据库API 与数据库服务器等外部数据源进行通信,从数据库服务器中获取数据。格式化为HTML文档后，发送给浏览器，也可以将从浏览器获得的数据放到数据库中。几乎所有服务器都支持CGI,可用任何语言编写CGI,包括流行的C、C ++、VB 和Delphi 等。
>> CGI 分为标准CGI 和间接CGI两种。标准CGI 使用命令行参数或环境变量表示服务器的详细请求，服务器与浏览器通信采用标准输入输出方式。间接CGI 又称缓冲CGI,在CGI 程序和CGI 接口之间插入一个缓冲程序，缓冲程序与CGI 接口间用标准输入输出进行通信。

> CGI 是WWW技术中最重要的技术之一，有着不可替代的重要地位。CGI是外部应用程序（CGI程序）与WEB服务器之间的接口标准，是在CGI程序和Web服务器之间传递信息的过程。CGI规范允许Web服务器执行外部程序，并将它们的输出发送给Web浏览器，CGI将Web的一组简单的静态超媒体文档变成一个完整的新的交互式媒体。绝大多数的CGI程序被用来解释处理来自表单的输入信息，并在服务器产生相应的处理，或将相应的信息反馈给浏览器。CGI程序使网页具有交互功能。

+ What if too many requests come in at once?


----------------

* Thread Pools

	+ Problem with previous version: Unbounded Threads
		- When web-site becomes too popular - throughput sinks(吞吐量下降、生产量下降)

	+ Instead, allocate a bounded "pool" of threads, representing the maximum level of multiprogramming

	![Thread Pools](images/06-002.png "Thread Pools")

>> De-queue 和 queue 是simultaneously 同时的。

> Thread pool is a pretty simple technique, but it lets us get by the unbounded parallelism problem while same time having the advantage of more than one thread.


----------------

* ATM Bank Server
![ATM Bank Server](images/06-003.png "ATM Bank Server")


* Example
![ATM Bank Server](images/06-004.png "ATM Bank Server")

* How could we speed this up?
	+ More than one request being processed at once
	+ Event driven (overlap computation and I/O)
	+ Multiple threads (multi-proc, or overlap computation and I/O)


![Event Driven Version](images/06-005.png "Event Driven Version")

+ This technique is used for graphical programming
> The graphical programming model is so well defined and constrained that they can basically do this devision, they can kind of figure out where the event boundaries are and they can do it once for everybody that uses the windowing system.


----------------

* Can Threads Make This Easier?

	+ Threads yield overlapped I/O and computation without "deconstructing" code into non-blocking fragments
		- One thread per request

	+ Requests proceeds to completion, blocking as required：

![Threads](images/06-006.png "Threads")



![Multiprocessing vs. Multiprogramming](images/06-007.png "Multiprocessing vs. Multiprogramming")


-----------------

* Problem is at the lowest level

![Threads](images/06-008.png "Threads")

> 当Thread没有共享数据，两者没有任何影响和联系。
>
> 当Thread共享 data,取决于两个Thread的顺序等其他条件。


-----------------

* Atomic Operations (原子操作)

	+ To understand a concurrent program, we need to know what the underlying indivisible operations are!

	+ __Atomic Operation__: an operation that always runs to completion or not at all
		- It's _indivisible_: it cannot be stopped in the middle and state cannot be modified by someone else in the middle
		- Fundamental building block - if no atomic operations, then have no way for threads to work together

	+ On most machines, memory references and assignments (i.e. loads and stores) of words are atomic
		- Consequently - weird example that produces "3" on previous slide can't happen

	+ Many instructions are not atomic
		- Double-precision floating point store often not atomic
		- VAX and IBM 360 had an instruction to copy a whole array

> Atomic Operation(原子操作，不可被中断的一个或一系列操作。）指不会被线程调度机制打断的操作；一旦开始，就一直运行到结束，中间不会有任何 context switch（切换到另一个线程）。

> 2.术语定义
>> ![术语](images/06-009.png "术语")

> 3.处理器如何实现原子操作：32位IA-32处理器使用基于 _对缓存加锁_ 或 _总线加锁_ 的方式来实现多处理器之间的原子操作

>> 3.1 处理器自动保证基本内存操作的原子性:	首先处理器会自动保证基本的内存操作的原子性。处理器保证从系统内存当中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。奔腾6和最新的处理器能自动保证单处理器对同一个缓存行里进行16/32/64位的操作是原子的，但是复杂的内存操作处理器不能自动保证其原子性，比如跨总线宽度，跨多个缓存行，跨页表的访问。但是处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。

>> 3.2 使用总线锁保证原子性:
>>> 如果多个处理器同时对共享变量进行读改写（i++就是经典的读改写操作）操作，那么共享变量就会被多个处理器同时进行操作，这样读改写操作就不是原子的，操作完之后共享变量的值会和期望的不一致，举个例子：如果i=1,我们进行两次i++操作，我们期望的结果是3，但是有可能结果是2。 原因是有可能多个处理器同时从各自的缓存中读取变量i，分别进行加一操作，然后分别写入系统内存当中。那么想要保证读改写共享变量的操作是原子的，就必须保证CPU1读改写共享变量的时候，CPU2不能操作缓存了该共享变量内存地址的缓存。

>> 处理器使用总线锁就是来解决这个问题的。所谓总线锁就是使用处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住,那么该处理器可以独占使用共享内存。

>> 3.3 使用缓存锁保证原子性
>>> 在同一时刻我们只需保证对某个内存地址的操作是原子性即可，但总线锁定把CPU和内存之间通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大，最近的处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。频繁使用的内存会缓存在处理器的L1，L2和L3高速缓存里，那么原子操作就可以直接在处理器内部缓存中进行，并不需要声明总线锁，在奔腾6和最近的处理器中可以使用“缓存锁定”的方式来实现复杂的原子性。所谓“缓存锁定”就是如果缓存在处理器缓存行中内存区域在LOCK操作期间被锁定，当它执行锁操作回写内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时会起缓存行无效，在例1中，当CPU1修改缓存行中的i时使用缓存锁定，那么CPU2就不能同时缓存了i的缓存行。

>> 但是有两种情况下处理器不会使用缓存锁定。第一种情况是：当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行（cache line），则处理器会调用总线锁定。第二种情况是：有些处理器不支持缓存锁定。对于Inter486和奔腾处理器,就算锁定的内存区域在处理器的缓存行中也会调用总线锁定。

> 以上两个机制我们可以通过Inter处理器提供了很多LOCK前缀的指令来实现。比如位测试和修改指令BTS，BTR，BTC，交换指令XADD，CMPXCHG 和其他一些操作数和逻辑指令，比如ADD（加），OR（或）等，被这些指令操作的内存区域就会加锁，导致其他处理器不能同时访问它。

> 在java中可以通过锁和循环CAS的方式来实现原子操作。

--------------------

* Correctness Requirements

	+ Threaded programs must work for all interleavings of thread instruction sequences
		- Cooperating threads inherently non-deterministic and non-reproducible
		- Really hard to debug unless carefully designed!

	+ Example: Therac-25; Software errors caused the death of sesveral patients


![Correctness Requirements](images/06-010.png "Correctness")


--------------------

* Space Shuttle Example

![Correctness Requirements](images/06-011.png "Correctness")

> primary avionics 初级航空电子


--------------------

![Another Concurrent Program Example](images/06-012.png "Example")

![Another Concurrent Program Example](images/06-013.png "Example")

> Could this happen on a uniprocessor?
>> Yes! Unlikely, but if you depending on it not happenning, it will and your system will break...

--------------------

![Too much milk](images/06-014.png "Too much milk")


--------------------

* Definitions

	+ __Synchronization__:	using atomic operations to ensure cooperation between threads
		- For now, only loads and stores are atomic
		- We are going to show that its hard to build anything usefule with only reads and writes

	+ __Mutual Exclusion__: ensuring that only one thread does a particular thing at a time
		- One thread _excludes_ the other while doing its task

	+ __Critical Section__: piece of code that only one thread can execute at once. Only one thread at a time will get into this section of code.
		- Critical section is the result of mutual exclusion
		- Critical section and mutual exclusion are two ways of describing the same thing.

		> 每个线程中访问临界资源的那段程序称为 __临界区（Critical Section）__ （ _临界资源_ 是一次仅允许一个线程使用的共享资源）。每次只准许一个线程进入临界区，进入后不允许其他线程进入。不论是硬件临界资源，还是软件临界资源，多个线程必须互斥地对它进行访问。(critical section 是每个线程中访问临界资源的那段代码，不论是硬件临界资源，还是软件临界资源，多个线程必须互斥地对它进行访问。)


	+ __Lock__: prevents someone from doing something
		- Lock before entering critical section and before accessing shared data
		- Unlock when leaving, after accessing hared data
		- Wait if locked

		>>> All synchronization involves waiting



![Too much milk](images/06-015.png "Too much milk")

> Fixes too much !


--------------------

* Too Much Milk:	Correctness Properties

	+ Need to be careful about correctness of concurrent programs, since non-deterministic (非确定的)
		- Always write down behavior first
		- Impulse is to start coding first, then when it doesn't work, pull hair out
		- Instead, think first, then code

	+ What are the correctness properties for the "Too much milk" problem?？？
		- Never more than one person buys
		- Someone buys if needed

	+ Restrict ourselves to use only atomic load and store operations as building blocks (限制我们只使用原子负载和存储操作作为构建块)


--------------------
##### Solution 1

![Solution](images/06-016.png "Solution")

> Why only occasionally?
>>> These checks here are not atomic. Suppose that both of us check for there being no milk and now by the way, there is a invisible roomate. And both of you see there's no note at the same time, both of you leave a note and head out to buy milk.

>> So there is a synchronization condition built into this code that is a weird interleaving where things switch just at the wrong time. Right after you've looked throught the conditions you switch over to the other guy they look through the condition they leave not you come back and leave the note...

> 这种情况其实更差。因为看似解决掉了问题所在，但实际上有少数机会还是会发生错误，并且很难debug！


--------------------

##### Solution 1.5

![Solution](images/06-017.png "Solution")


--------------------

##### Solution 2

![Solution](images/06-018.png "Solution")

> Maby A leave a note and B leave a note, then nobody buys any milk.

> 在极少数情况下会出错、发生没有人去购买牛奶，因为彼此都认为对方会去购买。这种极端的潜在的情况下发生会使得非常的麻烦。This is one of the heisenbugs or it looks like it that it's going to show up at the worst possible time. This one's even less likely than the previous one.

![Solution](images/06-019.png "Solution")

> 与并发相关的关键术语:
>> __原子操作__ ：要保证指令的序列作为一个组来操作执行，要么都不执行；要么执行要直接执行到指令完毕，中间不能中断

>> __临界区__ ：是一段代码，在这段代码中进程将访问共享资源，当有一个进程在这段代码中运行时，其他进程不能在这段代码中运行

>> __死锁__ ：两个或两个以上的进程因其中的每个进程都在等待其他进程做完某些事情而不能继续执行，这种情形称为死锁

>> __互斥__ ：当一个进程在临界区访问共享资源时，其他进程不能进入该临界区访问任何共享资源，这种情形称为互斥

>> __同步__ ：同步是在互斥的基础上（大多数情况），通过对其他机制实现访问者对资源的有序访问

>> __饥饿__ ：指一个可运行的进程尽管能继续执行，但被调度程序无限期地忽视，而不能调度执行的情形

>> __竞争条件__ ：多个线程或进程在读写一个共享数据时，结果依赖于它们执行的相对时间，这种情形称为竞争条件


--------------------

##### Solution 3

![Solution](images/06-020.png "Solution")

>> One thing we can say about this code is each chunk(块）here is protecting a critical section. So basically think of this part leave note A while note B is an entry and the remove note is a exit and this if no milk buy milk is a critical section. And it's over here to that we want to make sure only one of the people do at a time. We don't want any interleaving on the if no milk buy milk critical section. That's what this is being what we're protecting here.

![Solution](images/06-021.png "Solution")


--------------------

##### Solution 4

![Solution](images/06-022.png "Solution")


--------------------

#### Summary

* Concurrent threads are a very useful abstraction
	+ Allow transparent overlapping of computation and I/O
	+ Allow use of parallel processing(并行处理) when available
